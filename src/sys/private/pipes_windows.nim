#
#            Abstractions for operating system services
#                   Copyright (c) 2021 Leorize
#
# Licensed under the terms of the MIT license which can be found in
# the file "license.txt" included with this distribution. Alternatively,
# the full text can be found at: https://spdx.org/licenses/MIT.html

import std/strformat
import pkg/winim/core as wincore except Handle
import ".." / handles
import errors

const
  BufferSize = 0
    ## Pipe buffer size. `0` means Windows' default.

  NamedPipePrefix = r"\\.\pipe\nim-sys"
    ## The prefix used for anonymous pipes generated by this module.

# TODO: when sys/random inevitably come to live, move this there
proc secureRandomUint(): BiggestUInt =
  ## Generate a random number of the biggest uint type using the operating
  ## system cryptographic random number engine.
  let status = BCryptGenRandom(nil, cast[PUChar](addr result),
                               ULong sizeof(result),
                               BCryptUseSystemPreferredRng)
  if status != StatusSuccess:
    raise newOSError(RtlNtStatusToDosError(status),
                     "Could not produce random numbers")

proc generateUniquePipeName(): string =
  ## Generate a completely unique name for a pipe.
  result = fmt"{NamedPipePrefix}.{GetCurrentProcessID()}.{secureRandomUint()}"

template newPipeImpl() {.dirty.} =
  var sa: SecurityAttributes
  sa.nLength = DWORD sizeof(sa)
  sa.bInheritHandle = WinBool(ffInheritable in flags)

  when Rd is ReadPipe and Wr is WritePipe:
    var rd, wr: wincore.Handle
    if CreatePipe(addr rd, addr wr, addr sa, BufferSize) == 0:
      raise newOSError(GetLastError(), ErrorPipeCreation)
  else:
    let
      rdExtraFlags: DWORD =
        when Rd is AsyncReadPipe:
          FileFlagOverlapped
        else:
          0
      wrExtraFlags: DWORD =
        when Wr is AsyncWritePipe:
          FileFlagOverlapped
        else:
          0

      pipeName = generateUniquePipeName()
      rd = CreateNamedPipeA(
        addr pipeName[0],
        dwOpenMode = PipeAccessInbound or
          FileFlagFirstPipeInstance or
          rdExtraFlags,
        dwPipeMode = PipeTypeByte or
          PipeWait or
          PipeRejectRemoteClients,
        nMaxInstances = 1,
        nOutBufferSize = BufferSize,
        nInBufferSize = BufferSize,
        nDefaultTimeout = 0,
        addr sa
      )

    if rd == InvalidHandleValue:
      raise newOSError(GetLastError(), ErrorPipeCreation)

    let wr = CreateFileA(addr pipeName[0], GenericWrite, dwShareMode = 0, addr sa,
                         OpenExisting, wrExtraFlags,
                         hTemplateFile = cast[wincore.Handle](nil))

    if wr == InvalidHandleValue:
      raise newOSError(GetLastError(), ErrorPipeCreation)

  result.rd =
    when Rd is ReadPipe:
      ReadPipe newFile(FD rd)
    else:
      AsyncReadPipe newAsyncFile(FD rd)
  result.wr =
    when Wr is WritePipe:
      WritePipe newFile(FD wr)
    else:
      AsyncWritePipe newAsyncFile(FD wr)
